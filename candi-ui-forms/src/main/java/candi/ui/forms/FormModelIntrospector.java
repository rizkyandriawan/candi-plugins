package candi.ui.forms;

import candi.ui.forms.annotation.*;

import java.lang.annotation.Annotation;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.*;

/**
 * Introspects a model class and returns a list of {@link FormField} descriptors.
 * Reads Java type info, Candi form annotations, and Jakarta Bean Validation annotations
 * to determine how each field should be rendered in a form.
 */
public class FormModelIntrospector {

    /**
     * Introspect the given model object and return an ordered list of form fields.
     *
     * @param model the model instance (used to read current field values)
     * @return list of FormField descriptors, ordered by @FormOrder then declaration order
     */
    public static List<FormField> introspect(Object model) {
        if (model == null) {
            return Collections.emptyList();
        }

        Class<?> clazz = model.getClass();
        List<Field> allFields = collectFields(clazz);
        List<FormField> result = new ArrayList<>();
        int declarationIndex = 0;

        for (Field field : allFields) {
            // Skip @FormIgnore fields
            if (field.isAnnotationPresent(FormIgnore.class)) {
                continue;
            }

            String name = field.getName();
            String inputType = determineInputType(field);
            String label = determineLabel(field);
            Object value = getFieldValue(model, field);
            boolean required = isRequired(field);
            Integer minLength = getMinLength(field);
            Integer maxLength = getMaxLength(field);
            Number min = getMin(field);
            Number max = getMax(field);
            String pattern = getPattern(field);
            String[] options = getOptions(model, field);
            String group = getGroup(field);
            int order = getOrder(field, declarationIndex);

            result.add(new FormField(
                    name, inputType, label, value,
                    required, minLength, maxLength, min, max,
                    pattern, options, group, order
            ));

            declarationIndex++;
        }

        // Sort by order value
        result.sort(Comparator.comparingInt(FormField::order));

        return result;
    }

    /**
     * Collect all declared fields from the class hierarchy (including superclasses),
     * excluding Object fields.
     */
    private static List<Field> collectFields(Class<?> clazz) {
        List<Field> fields = new ArrayList<>();
        Class<?> current = clazz;
        while (current != null && current != Object.class) {
            // Prepend superclass fields so they appear first (parent fields before child fields)
            List<Field> declared = new ArrayList<>(Arrays.asList(current.getDeclaredFields()));
            // Filter out synthetic fields (e.g., generated by compiler)
            declared.removeIf(Field::isSynthetic);
            fields.addAll(0, declared);
            current = current.getSuperclass();
        }
        return fields;
    }

    /**
     * Determine the HTML input type based on field type and annotations.
     */
    private static String determineInputType(Field field) {
        // Annotation-based overrides first
        if (field.isAnnotationPresent(FormHidden.class)) {
            return "hidden";
        }
        if (field.isAnnotationPresent(FormTextarea.class)) {
            return "textarea";
        }
        if (field.isAnnotationPresent(FormSelect.class)) {
            return "select";
        }

        // Check for @Email from Bean Validation
        if (hasAnnotation(field, "jakarta.validation.constraints.Email")) {
            return "email";
        }

        // Type-based detection
        Class<?> type = field.getType();

        if (type == boolean.class || type == Boolean.class) {
            return "checkbox";
        }
        if (type == int.class || type == Integer.class || type == long.class || type == Long.class) {
            return "number";
        }
        if (type == BigDecimal.class || type == double.class || type == Double.class
                || type == float.class || type == Float.class) {
            return "decimal";
        }
        if (type == LocalDate.class) {
            return "date";
        }
        if (type == LocalDateTime.class) {
            return "datetime-local";
        }
        if (type == String.class) {
            return "text";
        }

        // Default to text for unknown types
        return "text";
    }

    /**
     * Determine the label for a field. Uses @FormLabel if present, otherwise
     * capitalizes the field name and splits camelCase.
     */
    private static String determineLabel(Field field) {
        FormLabel labelAnnotation = field.getAnnotation(FormLabel.class);
        if (labelAnnotation != null) {
            return labelAnnotation.value();
        }
        return formatLabel(field.getName());
    }

    /**
     * Convert a camelCase field name to a human-readable label.
     * e.g., "firstName" -> "First Name", "email" -> "Email"
     */
    private static String formatLabel(String fieldName) {
        if (fieldName == null || fieldName.isEmpty()) return "";
        StringBuilder sb = new StringBuilder();
        sb.append(Character.toUpperCase(fieldName.charAt(0)));
        for (int i = 1; i < fieldName.length(); i++) {
            char c = fieldName.charAt(i);
            if (Character.isUpperCase(c)) {
                sb.append(' ');
            }
            sb.append(c);
        }
        return sb.toString();
    }

    /**
     * Read the current value of a field from the model object via its getter method.
     */
    private static Object getFieldValue(Object model, Field field) {
        String name = field.getName();
        Class<?> clazz = model.getClass();

        // Try getXxx()
        try {
            String getter = "get" + Character.toUpperCase(name.charAt(0)) + name.substring(1);
            Method m = clazz.getMethod(getter);
            return m.invoke(model);
        } catch (Exception ignored) {
        }

        // Try isXxx() for booleans
        if (field.getType() == boolean.class || field.getType() == Boolean.class) {
            try {
                String isGetter = "is" + Character.toUpperCase(name.charAt(0)) + name.substring(1);
                Method m = clazz.getMethod(isGetter);
                return m.invoke(model);
            } catch (Exception ignored) {
            }
        }

        // Fallback: direct field access
        try {
            field.setAccessible(true);
            return field.get(model);
        } catch (Exception ignored) {
        }

        return null;
    }

    /**
     * Check if a field is required based on Bean Validation annotations.
     */
    private static boolean isRequired(Field field) {
        return hasAnnotation(field, "jakarta.validation.constraints.NotNull")
                || hasAnnotation(field, "jakarta.validation.constraints.NotBlank")
                || hasAnnotation(field, "jakarta.validation.constraints.NotEmpty");
    }

    /**
     * Get the minlength from @Size annotation.
     */
    private static Integer getMinLength(Field field) {
        Object size = getAnnotationInstance(field, "jakarta.validation.constraints.Size");
        if (size != null) {
            try {
                Method minMethod = size.getClass().getMethod("min");
                int min = (int) minMethod.invoke(size);
                if (min > 0) return min;
            } catch (Exception ignored) {
            }
        }
        return null;
    }

    /**
     * Get the maxlength from @Size annotation.
     */
    private static Integer getMaxLength(Field field) {
        Object size = getAnnotationInstance(field, "jakarta.validation.constraints.Size");
        if (size != null) {
            try {
                Method maxMethod = size.getClass().getMethod("max");
                int max = (int) maxMethod.invoke(size);
                if (max < Integer.MAX_VALUE) return max;
            } catch (Exception ignored) {
            }
        }
        return null;
    }

    /**
     * Get the min value from @Min annotation.
     */
    private static Number getMin(Field field) {
        Object min = getAnnotationInstance(field, "jakarta.validation.constraints.Min");
        if (min != null) {
            try {
                Method valueMethod = min.getClass().getMethod("value");
                return (long) valueMethod.invoke(min);
            } catch (Exception ignored) {
            }
        }
        return null;
    }

    /**
     * Get the max value from @Max annotation.
     */
    private static Number getMax(Field field) {
        Object max = getAnnotationInstance(field, "jakarta.validation.constraints.Max");
        if (max != null) {
            try {
                Method valueMethod = max.getClass().getMethod("value");
                return (long) valueMethod.invoke(max);
            } catch (Exception ignored) {
            }
        }
        return null;
    }

    /**
     * Get the pattern from @Pattern annotation.
     */
    private static String getPattern(Field field) {
        Object pattern = getAnnotationInstance(field, "jakarta.validation.constraints.Pattern");
        if (pattern != null) {
            try {
                Method regexpMethod = pattern.getClass().getMethod("regexp");
                return (String) regexpMethod.invoke(pattern);
            } catch (Exception ignored) {
            }
        }
        return null;
    }

    /**
     * Get options for @FormSelect fields. Supports static options and dynamic optionsFrom.
     */
    private static String[] getOptions(Object model, Field field) {
        FormSelect selectAnnotation = field.getAnnotation(FormSelect.class);
        if (selectAnnotation == null) {
            return null;
        }

        // Try dynamic options first
        String optionsFrom = selectAnnotation.optionsFrom();
        if (optionsFrom != null && !optionsFrom.isEmpty()) {
            try {
                Method method = model.getClass().getMethod(optionsFrom);
                Object result = method.invoke(model);
                if (result instanceof String[] arr) {
                    return arr;
                }
                if (result instanceof List<?> list) {
                    return list.stream().map(String::valueOf).toArray(String[]::new);
                }
            } catch (Exception ignored) {
            }
        }

        // Fall back to static options
        String[] options = selectAnnotation.options();
        if (options.length > 0) {
            return options;
        }

        return new String[0];
    }

    /**
     * Get the group name from @FormGroup annotation.
     */
    private static String getGroup(Field field) {
        FormGroup groupAnnotation = field.getAnnotation(FormGroup.class);
        return groupAnnotation != null ? groupAnnotation.value() : null;
    }

    /**
     * Get the order value from @FormOrder annotation, falling back to declaration index.
     */
    private static int getOrder(Field field, int declarationIndex) {
        FormOrder orderAnnotation = field.getAnnotation(FormOrder.class);
        return orderAnnotation != null ? orderAnnotation.value() : (1000 + declarationIndex);
    }

    /**
     * Check if a field has an annotation by its fully qualified class name.
     * Uses string-based lookup to avoid hard dependency on jakarta.validation.
     */
    private static boolean hasAnnotation(Field field, String annotationClassName) {
        for (Annotation annotation : field.getAnnotations()) {
            if (annotation.annotationType().getName().equals(annotationClassName)) {
                return true;
            }
        }
        return false;
    }

    /**
     * Get an annotation instance by its fully qualified class name.
     */
    private static Object getAnnotationInstance(Field field, String annotationClassName) {
        for (Annotation annotation : field.getAnnotations()) {
            if (annotation.annotationType().getName().equals(annotationClassName)) {
                return annotation;
            }
        }
        return null;
    }
}
